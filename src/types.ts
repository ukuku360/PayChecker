export type JobType = string;

export interface RateHistoryItem {
  effectiveDate: string; // YYYY-MM-DD
  rates: {
    weekday: number;
    saturday: number;
    sunday: number;
    holiday: number;
  };
}

export interface JobConfig {
  id: string;
  name: string;
  color: string; // tailwind color name (e.g., 'blue', 'emerald')
  defaultHours: {
    weekday: number;
    weekend: number;
  };
  hourlyRates: {
    weekday: number;
    saturday: number;
    sunday: number;
    holiday: number;
  };
  rateHistory: RateHistoryItem[];
  defaultBreakMinutes?: number; // Unpaid break time in minutes (default: 0)
  defaultStartTime?: string; // HH:MM
  defaultEndTime?: string; // HH:MM
}

export interface WageConfig {
  [jobType: string]: {
    weekday: number;
    saturday: number;
    sunday: number;
    holiday: number;
  };
}

export interface Shift {
  id: string;
  date: string; // ISO date string YYYY-MM-DD
  type: JobType;
  hours: number;
  note?: string;
  startTime?: string; // HH:MM
  endTime?: string; // HH:MM
  breakMinutes?: number;
}

export interface Holiday {
  date: string; // YYYY-MM-DD
  name: string;
}

export interface VacationPeriod {
  start: string; // YYYY-MM-DD
  end: string; // YYYY-MM-DD
}

export type ExpenseCategory = 
  | 'housing' 
  | 'utility' 
  | 'subscription' 
  | 'grocery' 
  | 'transport'
  | 'insurance'
  | 'investment' 
  | 'other';

export interface Expense {
  id: string;
  name: string;
  amount: number;
  category: ExpenseCategory;
  isRecurring: boolean; // true = Îß§Îã¨ Í≥†Ï†ï, false = ÏùºÌöåÏÑ± (Ìï¥Îãπ ÏõîÎßå)
  month?: string; // YYYY-MM (ÏùºÌöåÏÑ±Ïùº Í≤ΩÏö∞Îßå ÏÇ¨Ïö©)
}

export const EXPENSE_CATEGORIES: { value: ExpenseCategory; label: string; emoji: string }[] = [
  { value: 'housing', label: 'Housing', emoji: 'üè†' },
  { value: 'utility', label: 'Utilities', emoji: 'üí°' },
  { value: 'subscription', label: 'Subscriptions', emoji: 'üì±' },
  { value: 'grocery', label: 'Groceries', emoji: 'üõí' },
  { value: 'transport', label: 'Transport', emoji: 'üöó' },
  { value: 'insurance', label: 'Insurance', emoji: 'üõ°Ô∏è' },
  { value: 'investment', label: 'Investment', emoji: 'üìà' },
  { value: 'other', label: 'Other', emoji: 'üì¶' },
];

export interface Feedback {
  id: string;
  user_id: string;
  message: string;
  type: 'feedback' | 'feature_request' | 'bug';
  created_at: string;
  status: 'new' | 'read' | 'completed';
  user_email?: string;
  admin_reply?: string;
  reply_created_at?: string;
}

export interface FeedbackReply {
  id: string;
  feedback_id: string;
  sender_id: string;
  content: string;
  is_admin_reply: boolean;
  created_at: string;
}

// Roster Scanner Types
export interface ParsedShift {
  id: string;
  date: string; // YYYY-MM-DD
  startTime: string | null; // HH:MM or null if not on roster
  endTime: string | null; // HH:MM or null if not on roster
  totalHours: number | null; // null if times not available
  rosterJobName: string; // Original name from roster (e.g., "RL", "AM")
  mappedJobId?: string; // User's JobConfig id (after mapping)
  confidence: number; // 0-1 confidence score from AI
  selected: boolean; // Whether user wants to add this shift
  hasConflict?: boolean; // Conflicts with existing shift
  conflictShiftId?: string; // ID of conflicting shift
}

export interface IdentifiedPerson {
  nameFound: string;
  location: string;
  matchType: 'exact' | 'firstName' | 'lastName' | 'initials' | 'substring' | 'color' | 'position';
  confidence: number;
}

// Extracted content from image (flexible format)
export interface OcrResult {
  success: boolean;
  contentType?: 'table' | 'list' | 'email' | 'text' | 'mixed';
  
  // For table format
  tableType?: 'column-based' | 'row-based' | 'unknown';
  headers?: string[];
  rows?: string[][];
  
  // Pre-extracted shifts (when AI can extract directly)
  extractedShifts?: Array<{
    date: string;
    startTime?: string;
    endTime?: string;
    location?: string;
    jobName?: string;
    note?: string;
  }>;
  
  // Questions generated by AI (if clarification needed)
  questions?: SmartQuestion[];
  
  metadata?: {
    title?: string;
    dateRange?: string;
    personName?: string;
    rowCount?: number;
    columnCount?: number;
    hasMultiplePeople?: boolean;
    potentialNames?: string[];
    language?: string;
  };
  
  // Raw text for fallback parsing
  rawText?: string;
  
  error?: string;
}

// Smart Question Types (AI-generated)
export interface QuestionOption {
  label: string;
  value: string;
  description?: string;
}

export interface SmartQuestion {
  id: string;
  type: 'single_select' | 'text';
  question: string;
  options?: QuestionOption[];
  required: boolean;
}

export interface QuestionAnswer {
  questionId: string;
  value: string;
}

// Pre-analysis from Phase 2 (analysis step)
export interface PreAnalysis {
  detectedPerson: string | null;
  dateFormat: string;
  timeFormat: string;
  shiftPatterns?: string[];
}

export interface QuestionGenerationResult {
  success: boolean;
  questions: SmartQuestion[];
  ocrData: OcrResult;
  skipToExtraction?: boolean; // If true, skip questions and go straight to extraction
  preAnalysis?: PreAnalysis;
  processingTimeMs?: number;
  scansUsed?: number;
  scanLimit?: number;
  error?: string;
  errorType?: string;
}

export interface RosterScanResult {
  success: boolean;
  shifts: ParsedShift[];
  processingTimeMs: number;
  identifiedPerson?: IdentifiedPerson | null;
  ocrData?: OcrResult; // OCR data for debugging
  error?: string;
  errorType?: 'blurry' | 'no_shifts' | 'timeout' | 'limit_exceeded' | 'unknown' | 'auth' | 'network' | 'parse_error' | 'not_roster' | 'config' | 'invalid_input' | 'identifier_not_found' | 'ocr_failed' | 'filter_failed' | 'no_table';
}

export interface JobAlias {
  id: string;
  user_id: string;
  job_config_id: string;
  alias: string;
  created_at?: string;
}

export interface RosterScan {
  id: string;
  user_id: string;
  parsed_result: RosterScanResult;
  shifts_created: number;
  processing_time_ms: number;
  created_at: string;
}

// Roster identifier for filtering shifts by user
export interface RosterIdentifier {
  name?: string;           // Name as shown on roster (e.g., "ÍπÄÏ≤†Ïàò", "John", "J.S.")
  color?: string;          // Color coding (e.g., "blue", "yellow highlight")
  position?: string;       // Row/column position (e.g., "3rd row", "column B")
  customNote?: string;     // Any other identifying information
}
